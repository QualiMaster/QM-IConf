package de.uni_hildesheim.sse.repositoryConnector.svnConnector;

/**
 * ====================================================================
 * Copyright (c) 2004-2008 TMate Software Ltd.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://svnkit.com/license.html
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 * ====================================================================
 * http://wiki.svnkit.com/Managing_A_Working_Copy
 */

import org.tmatesoft.svn.core.SVNCancelException;
import org.tmatesoft.svn.core.wc.ISVNEventHandler;
import org.tmatesoft.svn.core.wc.SVNEvent;
import org.tmatesoft.svn.core.wc.SVNEventAction;
import org.tmatesoft.svn.core.wc.SVNStatusType;

/**
 * This class is an implementation of ISVNEventHandler intended for processing events generated by do*() methods of an
 * SVNUpdateClient object. An instance of this handler will be provided to an SVNUpdateClient. When calling, for
 * example, SVNWCClient.doUpdate(..) on some path, that method will generate an event for each
 * 'update'/'add'/'delete'/.. action it will perform upon every path being updated. And this event is passed to
 * 
 * ISVNEventHandler.handleEvent(SVNEvent event, double progress)
 * 
 * to notify the handler. The event contains detailed information about the path, action performed upon the path and
 * some other.
 */
public class UpdateEventHandler implements ISVNEventHandler {
    
//    private static EASyLogger logger = EASyLoggerFactory.INSTANCE.getLogger(UpdateEventHandler.class, Bundle.ID);
    
    private RepositoryEventHandler handler;
    
    /**
     * progress is currently reserved for future purposes and now is always ISVNEventHandler.UNKNOWN.
     * 
     * @param event event
     * @param progress  progress
     */
    public void handleEvent(SVNEvent event, double progress) {
        SVNEventAction action = event.getAction();
        if (handler !=  null && action != SVNEventAction.UPDATE_STARTED && action != SVNEventAction.UPDATE_COMPLETED) {
            handler.progress(1);
        } else if (handler !=  null && action == SVNEventAction.UPDATE_COMPLETED) {
            handler.completed();
        }
        String pathChangeType = " ";
        boolean isReturn = false;
        if (action == SVNEventAction.UPDATE_ADD) {
            pathChangeType = "A";
        } else if (action == SVNEventAction.UPDATE_DELETE) {
            pathChangeType = "D";
        } else if (action == SVNEventAction.UPDATE_UPDATE) {
            SVNStatusType contentsStatus = event.getContentsStatus();
            if (contentsStatus == SVNStatusType.CHANGED) {
                pathChangeType = "U";
            } else if (contentsStatus == SVNStatusType.CONFLICTED) {
                pathChangeType = "C";
            } else if (contentsStatus == SVNStatusType.MERGED) {
                pathChangeType = "G";
            }
        } else if (action == SVNEventAction.UPDATE_EXTERNAL) {
            System.out.println("Fetching external item into '" + event.getFile().getAbsolutePath() + "'");
            System.out.println("External at revision " + event.getRevision());
            isReturn = true;
        } else if (action == SVNEventAction.UPDATE_COMPLETED) {
            System.out.println("At revision " + event.getRevision());
            isReturn = true;
        } else if (action == SVNEventAction.ADD) {
            System.out.println("A     " + event.getFile().getAbsolutePath());
            isReturn = true;
        } else if (action == SVNEventAction.DELETE) {
            System.out.println("D     " + event.getFile().getAbsolutePath());
            isReturn = true;
        } else if (action == SVNEventAction.LOCKED) {
            System.out.println("L     " + event.getFile().getAbsolutePath());
            isReturn = true;
        } else if (action == SVNEventAction.LOCK_FAILED) {
            System.out.println("failed to lock    " + event.getFile().getAbsolutePath());
            isReturn = true;
        }
        if (isReturn) {
            return;
        }
        SVNStatusType propertiesStatus = event.getPropertiesStatus();
        String propertiesChangeType = " ";
        if (propertiesStatus == SVNStatusType.CHANGED) {
            propertiesChangeType = "U";
        } else if (propertiesStatus == SVNStatusType.CONFLICTED) {
            propertiesChangeType = "C";
        } else if (propertiesStatus == SVNStatusType.MERGED) {
            propertiesChangeType = "G";
        }
        String lockLabel = " ";
        SVNStatusType lockType = event.getLockStatus();
        if (lockType == SVNStatusType.LOCK_UNLOCKED) {
            lockLabel = "B";
        }
        System.out.println(pathChangeType + propertiesChangeType + lockLabel + "       "
                + event.getFile().getAbsolutePath());
    }

    /**
     * Should be implemented to check if the current operation is cancelled. If it is, this method should throw an
     * SVNCancelException.
     * 
     * @throws SVNCancelException exception
     */
    public void checkCancelled() throws SVNCancelException {
    }

    /**
     * Sets the EventHandler.
     * @param handler The EventHandler to be set.
     */
    public void setHandler(RepositoryEventHandler handler) {
        this.handler = handler;
    }

}